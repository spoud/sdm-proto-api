syntax = "proto3";
package io.spoud.sdm.looker.v1alpha1;

option java_multiple_files = true;
option java_package = "io.spoud.sdm.looker.v1alpha1";
option go_package = "looker.v1alpha1";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
import "global/selection/v1/pagination.proto";
import "permission/domain/v1/domain.proto";

service LookerService {
  // used by the profiler
  rpc updateDataProfile (UpdateDataProfileRequest) returns (UpdateDataProfileResponse);

  // used by the UI
  rpc getDataProfile (GetDataProfileRequest) returns (GetDataProfileResponse);

  rpc listDataProfilingJobs (ListDataProfilingJobsRequest) returns (ListDataProfilingJobsResponse);
}

message DataProfilingError {
  string message = 1;

  enum Type {
    UNKNOWN = 0;
    PROFILER_UNREACHABLE = 1;
    UNKNOWN_ENCODING = 2;
    ACCESS_DENIED = 3;
    NO_DATA = 4;
    TRANSPORT_UNAVAILABLE = 5;
    NO_PARTITION = 6;
  }

  Type type = 2;
}

// DataProfile
message DataProfile {
  string id = 1;
  // references the job which triggered this profiling
  string data_profiling_job_id = 2;

  int32 data_samples_count = 4;
  // Report creation timestamp, does not have to
  // be related to the timestamp of the profiled messages.
  google.protobuf.Timestamp report_timestamp = 5;

  // reference to the transport offer id
  string transport_offer_id = 8;

  google.protobuf.Timestamp data_samples_from = 9;
  google.protobuf.Timestamp data_samples_to = 10;

  // if there's an error set, the profiling returns without a report.
  DataProfilingError error = 12;

  // this contains a UUID for the profile which is stored in the blob service
  string html_blob_id = 13;

  io.spoud.sdm.permission.domain.v1.PrivilegeInformation privilege = 14;
}

// XXX(lza): why don't we just pass a DataProfile Message (above) in the Request?
message UpdateDataProfileRequest {

  // references the job which triggered this profiling
  string data_profiling_job_id = 1;

  // amount of messages taken into account for the profiling
  int32 data_samples_count = 3;

  // Report creation timestamp, does not have to
  // be related to the timestamp of the profiled messages.
  google.protobuf.Timestamp report_timestamp = 4;

  // if there's an error set, the profiling returned without a report.
  DataProfilingError error = 5;

  google.protobuf.Timestamp data_samples_from = 6;
  google.protobuf.Timestamp data_samples_to = 7;

  int32 total_records_read = 9;
  int32 total_records_processed = 10;

  // stats about size of profile
  int32 profile_size_bytes = 11;

  // versions used
  string profiler_service_version = 13;
  string profiler_version = 14;

  // the SkipStrategyType seed (usually the one used last time)
  SkipStrategyType.Type skipStrategyType = 15;

  // this contains a set of DataSample. In the error case we can expect a sample of the sampling
  // data in order to understand what went wrong.
  repeated DataSample samples = 16;

  // this contains a UUID for the profile which is stored in the blob service
  string html_blob_id = 17;
}

message DataSample {
  enum Encoding {
    UNKNOWN = 0;
    JSON = 1;
    AVRO = 2;
  }

  Encoding encoding = 1;
  bytes data_sample = 2;
}

message UpdateDataProfileResponse {
  DataProfile data_profile = 1;
}

enum NotExistsResolution {
  THROW_ERROR = 0;
  RETURN_EMPTY = 1;
}

// Get data profile by id or transport_offer_id
message GetDataProfileRequest {

  // get data profile by id
  string id = 1;

  // get data profile by transport offer id
  string transport_offer_id = 2;

  // define error handling if data profile cannot be found.
  NotExistsResolution not_exists_resolution = 3;
}

message GetDataProfileResponse {
  DataProfile data_profile = 1;
}

// DataProfileJob

// A DataProfileJob gets created for each TransportOffer (if it's synchronized)
message DataProfilingJob {

  // unique identifier of the job
  string id = 1;

  // transport offer reference
  // needed to link it with external services / logistics
  // especially useful for a data profile search.
  string transport_offer_id = 2;

  // transport id reference, needed to group/list by transport
  string transport_id = 3;

  // transport url contains all endpoint information to access the content.
  // e.g. for kafka it's the following template: `kafka://<bootstrap-servers>?topic=<topic-name>`
  // example: `kafka://kafka-1.spoud.io:9092,kafka-2.spoud.io:9092?topic=sdm-topic-xy`
  string transport_url = 4;

  // the SkipStrategyType seed (usually the one used last time)
  SkipStrategyType.Type skipStrategyType = 5;

  // The path for the resource, used for permissions
  string path = 6;

  io.spoud.sdm.permission.domain.v1.PrivilegeInformation privilege = 7;

}

//this enum indicates the skip strategy which was last used by the profiler
message SkipStrategyType {
  enum Type {
    UNKNOWN = 0;
    SKIP_UP_TO_LATEST = 1;
    SKIP_HALF_TO_LATEST = 2;
    READ_BACKWARDS = 3;
  }
}

// data profiling jobs can be filtered by transport_id
message ListDataProfilingJobsRequest {
  io.spoud.sdm.global.selection.v1.PageRequest page_request = 2;

  // returns data profiling jobs with this transport id (uuid) only.
  // each profiler is responsible for a different transport id.
  string transport_id = 1;
}

// right now we expect to get an updateDataProfile for each
// job for each listing.
message ListDataProfilingJobsResponse {
  repeated DataProfilingJob jobs = 1;
  io.spoud.sdm.global.selection.v1.PageResult page_result = 2;
}
